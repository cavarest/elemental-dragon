name: release

on:
  workflow_dispatch:
    inputs:
      next_version:
        description: |
          Next release version. Possible values: x.y.z, major, minor, patch.
          Also, you can pass 'skip' to skip git tag and create release for the current version.
        required: true
        type: string
      release_title:
        description: 'Title for the GitHub release (optional, defaults to version)'
        required: false
        type: string
      release_notes:
        description: 'Release notes (optional, defaults to changelog)'
        required: false
        type: string
  push:
    tags:
      - 'v*.*.*'

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      actions: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get branch name
      id: branch_name
      run: |
        # Get the branch name from the ref that triggered the workflow
        if [[ "${{ github.ref }}" == "refs/tags/"* ]]; then
          # For tag triggers, get the default branch
          branch=$(git remote show origin | grep "HEAD branch" | sed 's/.*: //')
        else
          # For branch triggers or manual dispatch
          branch="${{ github.ref_name }}"
        fi
        echo "branch=$branch" >> $GITHUB_OUTPUT
        echo "Target branch: $branch"

    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x'

    - name: Get current version from gradle.properties
      id: current_version
      run: |
        import os
        import re

        with open('gradle.properties', 'r') as f:
            content = f.read()
            match = re.search(r"project\.version\s*=\s*([0-9.]+)", content)
            if match:
                version_str = match.group(1)
                with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                    f.write(f'current={version_str}\n')
                print(f'Found version: {version_str}')
            else:
                raise ValueError('Version not found in gradle.properties')
      shell: python

    - name: Calculate next version
      id: next_version
      run: |
        import os

        current_version = '${{ steps.current_version.outputs.current }}'
        next_version_input = '${{ inputs.next_version }}'

        # Parse current version manually
        parts = current_version.split('.')
        major, minor, patch = int(parts[0]), int(parts[1]), int(parts[2])

        # Calculate next version
        if next_version_input == 'major':
            next_ver = f'{major + 1}.0.0'
        elif next_version_input == 'minor':
            next_ver = f'{major}.{minor + 1}.0'
        elif next_version_input == 'patch':
            next_ver = f'{major}.{minor}.{patch + 1}'
        elif next_version_input == 'skip':
            next_ver = current_version
        else:
            next_ver = next_version_input

        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f'next={next_ver}\n')
            f.write(f'tag=v{next_ver}\n')
        print(f'Next version: {next_ver}')
      shell: python

    - name: Update version in gradle.properties
      if: ${{ inputs.next_version != '' && inputs.next_version != 'skip' }}
      run: |
        import re

        next_ver = '${{ steps.next_version.outputs.next }}'

        # Update gradle.properties (single source of truth)
        with open('gradle.properties', 'r') as f:
            content = f.read()
        content = re.sub(
            r'(project.version=).*',
            lambda m: m.group(1) + next_ver,
            content
        )
        with open('gradle.properties', 'w') as f:
            f.write(content)

        print(f'Updated version to {next_ver}')
      shell: python

    - name: Commit version bump
      if: ${{ inputs.next_version != '' && inputs.next_version != 'skip' }}
      run: |
        BRANCH="${{ steps.branch_name.outputs.branch }}"
        git config user.name github-actions
        git config user.email github-actions@github.com
        NEXT="${{ steps.next_version.outputs.next }}"
        git add gradle.properties
        git commit -m "chore: bump version to $NEXT"
        echo "Pushing to branch: $BRANCH"
        git push origin "$BRANCH"

    - name: Create and push git tag
      if: ${{ inputs.next_version != '' && inputs.next_version != 'skip' }}
      run: |
        TAG="${{ steps.next_version.outputs.tag }}"
        git tag -a "$TAG" -m "Release $TAG"
        git push origin "$TAG"
        echo "Created and pushed tag: $TAG"

    - name: Build plugin using Gradle (production build)
      run: |
        echo "ðŸ—ï¸ Building production plugin..."
        chmod +x build.sh
        ./build.sh --production
        echo "âœ… Plugin built successfully"

    - name: Build slim JAR for advanced users
      run: |
        echo "ðŸ“¦ Building slim JAR (no bundled dependencies)..."
        ./gradlew slimJar
        echo "âœ… Slim JAR built successfully"

    - name: Download dependency JARs
      run: |
        echo "ðŸ“¥ Downloading dependency JARs for GitHub release..."
        mkdir -p build/deps

        # Download ProtocolSidebar (latest master-SNAPSHOT)
        curl -L "https://jitpack.io/com/github/CatCoderr/ProtocolSidebar/master-SNAPSHOT/ProtocolSidebar-master-SNAPSHOT.jar" \
          -o build/deps/ProtocolSidebar-master-SNAPSHOT.jar || echo "âš ï¸  ProtocolSidebar download failed"

        # Download FoliaLib
        curl -L "https://repo.tcoded.com/releases/com/tcoded/FoliaLib/0.5.1/FoliaLib-0.5.1.jar" \
          -o build/deps/FoliaLib-0.5.1.jar || echo "âš ï¸  FoliaLib download failed"

        ls -lh build/deps/
        echo "âœ… Dependencies downloaded"

    - name: Verify plugin.yml structure
      run: |
        echo "ðŸ” Verifying plugin.yml structure..."
        JAR_FILE=$(find build/libs -name "elemental-dragon-*.jar" | head -1)
        echo "Found JAR: $JAR_FILE"
        jar tf "$JAR_FILE" | grep plugin.yml
        echo "âœ… Plugin.yml verified"

    - name: Create GitHub Release
      id: create_release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.next_version.outputs.tag }}
        name: ${{ inputs.release_title || format('Elemental Dragon Plugin {0}', steps.next_version.outputs.next) }}
        body: ${{ inputs.release_notes }}
        draft: false
        prerelease: false
        files: |
          build/libs/elemental-dragon-*.jar
          build/deps/*.jar
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Verify Release
      run: |
        echo "ðŸŽ‰ Release ${{ steps.next_version.outputs.tag }} created successfully!"
        echo ""
        echo "ðŸ”— https://github.com/${{ github.repository }}/releases/tag/${{ steps.next_version.outputs.tag }}"

    - name: Update CHANGELOG and cleanup
      shell: python
      run: |
        import os
        import re

        version = "${{ steps.next_version.outputs.next }}"
        date = os.popen("date +%Y-%m-%d").read().strip()

        print("ðŸ“ Updating CHANGELOG.md and cleaning up...")

        # Read RELEASE_NOTES.md if it exists
        if os.path.exists("RELEASE_NOTES.md"):
            with open("RELEASE_NOTES.md", "r") as f:
                release_notes = f.read()

            # Create new changelog entry
            new_entry = f"### [{version}] - {date}\n{release_notes}\n\n---\n"

            # Read CHANGELOG.md
            with open("CHANGELOG.md", "r") as f:
                changelog = f.read()

            # Insert new entry after "## [Unreleased]"
            pattern = r"(## \[Unreleased\])"
            changelog = re.sub(pattern, r"\1\n\n" + new_entry, changelog, count=1)

            # Write updated CHANGELOG.md
            with open("CHANGELOG.md", "w") as f:
                f.write(changelog)

            print("âœ… Updated CHANGELOG.md")

            # Remove RELEASE_NOTES.md
            os.remove("RELEASE_NOTES.md")
            print("âœ… Removed RELEASE_NOTES.md (template remains for next release)")
        else:
            print("âš ï¸ No RELEASE_NOTES.md found, skipping changelog update")

    - name: Commit CHANGELOG update
      run: |
        BRANCH="${{ steps.branch_name.outputs.branch }}"
        git config user.name github-actions
        git config user.email github-actions@github.com
        git add CHANGELOG.md RELEASE_NOTES.md 2>/dev/null || true
        git diff --staged --quiet || git commit -m "docs: update CHANGELOG for ${{ steps.next_version.outputs.tag }}"
        git push origin "$BRANCH"

    - name: Distribute to Modrinth and Hangar
      uses: benc-uk/workflow-dispatch@v1
      with:
        workflow: distribution.yml
        repo: ${{ github.repository }}
        token: ${{ secrets.GITHUB_TOKEN }}
        inputs: '{"tag": "${{ steps.next_version.outputs.tag }}", "release_title": "${{ inputs.release_title }}"}'
